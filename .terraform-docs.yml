version: ">= 0.16.0, < 1.0.0"

formatter: "markdown"

content: |-
  # Code Server AWS Terraform Module

  A Terraform module for deploying a standalone personal code-server instance on AWS with batteries incliuded.

  ## Features

  * Dedicated code-server instance
  * Authentication using Cognito and customizable username and password
  * Image Builder factory to produce always up to date instance images
  * Ability to attach persistent storage
  * API allowing on-demand realtime instance scale up and down
  * Ability to run server in private subnets for added ~~security~~ peace of mind

  ## Usage

  ### Basic

  ```hcl
  module "code_server" {
    source = "github.com/atanaspam/terraform-code-server-aws.git"

    region           = "eu-central-1"
    vpc_id           = data.aws_vpc.this.id
    private_subnets  = data.aws_subnets.private.ids
    public_subnets   = data.aws_subnets.public.ids
    base_domain_name = "mydomain.net"
  ```

  ### Custom username and password

  ```hcl
  module "code_server" {
    source = "github.com/atanaspam/terraform-code-server-aws.git"

    region               = "eu-central-1"
    vpc_id               = data.aws_vpc.this.id
    private_subnets      = data.aws_subnets.private.ids
    public_subnets       = data.aws_subnets.public.ids
    base_domain_name     = "mydomain.net"
    code_server_username = "myCustomUsername"
    code_server_password = "myPassword" # Don't hardcode me
  ```

  ## Manual scaling

  It is possible to deploy the code-server instance in a scaled-down state. This means that all the supporting infra will be depoyed but the actual code server instace will not be started until explicitly requested. This is done to allow quick server spin-up while avoinding most (all?) of the fixed costs since (almost) all the other infra is charged on demand.

  In order to scale your instace on demand, an API Gateway API has been created which takes HTTP POST requests that indicate the desired ASG replicas state for the code-server instace. The API endpoint requires the same username and password required to log in to the code-server instance, however authentication is performed via a different cognito endpoint. The controller URL is available as an output of the terraform module. 

  You can scale your instance using the examples below

  Using curl and jq:
  ```bash
  URL=$(terraform output -raw code_server_controller_endpoint)
  AUTH_ENDPOINT=$(terraform output -raw code_server_controller_authentication_endpoint)
  CS_USERNAME=$(terraform output -raw code_server_username)
  CS_PASSWORD=$(terraform output -raw code_server_password)
  COGNITO_CLIENT_ID=$(terraform output -raw cognito_client_id)
  TOKEN=$(curl -X POST $AUTH_ENDPOINT \
  --header 'X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth' \
  --header 'Content-Type: application/x-amz-json-1.1' \
  --data-raw "$(cat <<EOF
  {"AuthParameters" : {"USERNAME" : "$CS_USERNAME","PASSWORD" : "$CS_PASSWORD"},"AuthFlow" : "USER_PASSWORD_AUTH","ClientId" : "$COGNITO_CLIENT_ID"}
  EOF
  )" | jq -r '.AuthenticationResult.IdToken')

  curl -X POST $URL --header "Authorization: $TOKEN" --data-raw '{"DesiredCapacity": 1}'
  ```

  or using AWS CLI

  ```bash
  URL=$(terraform output code_server_controller_endpoint)
  USERNAME=$(terraform output code_server_username)
  PASSWORD=$(terraform output code_server_password)
  COGNITO_CLIENT_ID=$(terraform output cognito_client_id)

  TOKEN=$(aws cognito-idp initiate-auth \
    --auth-flow USER_PASSWORD_AUTH \
    --auth-parameters \
    USERNAME=$USERNAME,PASSWORD=$PASSWORD \
    --client-id $COGNITO_CLIENT_ID \
    --qquery "AuthenticationResult.IdToken")

  curl -X POST $URL --header "Authorization: $TOKEN" --data-raw '{"DesiredCapacity": 1}'
  ```

  ## Deploying to private or public subnets

  It is possible to deploy the code-server instance in your private subnets. This allows you to run your instance in an isolated network without direct internet access. This is a very niche requirement and imposes some limitations on what your instance can do. If you dont know what is going on you should **not** use this.
  If you choose to opt in for this setting, you also need to attach the appropriate VPC endpoints to your target VPC.

  * SSM: The Image Builder and code-server instance use the SSM agent for access and provisioning
  * SSM Messages: Same as above
  * EC2 Messages: Standard EC2 communication inside a private subnet without a NAT gateway
  * Image Builder: The Image Builder service spins up an instance in the private subnet in order to construct the base AMI
  * S3: The Image Builder components are hosted in S3 and required for building the code-server image

  {{ .Requirements }}

  {{ .Providers }}

  {{ .Inputs }}

  {{ .Outputs }}


output:
  file: README.md
  mode: inject
  template: |-
    <!-- BEGIN_TF_DOCS -->
    {{ .Content }}
    <!-- END_TF_DOCS -->
